/*
 * Name: Aryan Kakadia
 * Student ID: 117401103
 *
 */

#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sysexits.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include "command.h"
#include "executor.h"

#define FILE_PERMS 0664

/*
 * if < and > we just use the IR and IO
 * what if second condition in && is false
 */

int status;
/*
static void print_tree(struct tree *t);
*/
static void execute_command(struct tree *t) {

  /*int return_value = -1;*/
  if (t != NULL) {	
    int chdir_return_value = -1;

    if ((strcmp(t->argv[0], "exit") == 0)/* || (strcmp(t->argv[0], "hastalavista") == 0)*/) {
 
      exit(EXIT_SUCCESS);		
      
    } else if (strcmp(t->argv[0], "cd") == 0) {

      chdir_return_value = chdir(t->argv[1]);
     
      if (chdir_return_value == -1) {
	
	perror(t->argv[1]);

      }
     
    } else {
      pid_t child_pid;
      int exe_return_value = -1;

      if ((child_pid = fork()) < 0) {

	perror("fork");

      } else if (child_pid) {
	
	wait(&status);
/*
	int status;
	wait(&status);
	return_value = status;
*/
      } else {
		
	if (t->input != NULL) {
			
	  int fd;		
	  if ((fd = open(t->input, O_RDONLY)) < 0) {

	    perror(t->input);
				
	  } 
	  if ((dup2(fd, STDIN_FILENO)) < 0) {

	    perror("dup2");

	  }
	  close(fd);

	}
			
	if (t->output != NULL) {
			
	  int fd;	
	  if ((fd = open(t->output, O_WRONLY | O_CREAT | O_APPEND, FILE_PERMS)) < 0) {

	    perror(t->output);
				
	  } 
	  if ((dup2(fd, STDOUT_FILENO)) < 0) {

	    perror("dup2");

	  }
	  close(fd);

	}
	/* use execvp to execute the UNIX command input by the user */
	exe_return_value = execvp(t->argv[0], t->argv);
	/* print error message if the command is invalid */
	if (exe_return_value == -1) {

	  /*printf("Failed to execute %s\n",t->argv[0]);*/
	  fflush(stdout);
	  exit(EX_OSERR);

	}

	fflush(stdout);
	exit(EXIT_SUCCESS);

      }
 	

	
    }

  } 

  /*return return_value;*/

}

static void execute_conjunction(struct tree *t) {
  if(t != NULL) {
    if (t->conjunction == PIPE) {
     
	if (t->left->output != NULL) {

		printf("Ambiguous output redirect.\n");

	} else if (t->right->input != NULL) {

		printf("Ambiguous input redirect.\n");
	
	} else {

      int pipe_fd[2];
      pid_t child1_pid, child2_pid;
      
      if (pipe(pipe_fd) < 0) {

	perror("pipe");

      } 
	
      if ((child1_pid = fork()) < 0) {

	perror("fork");

      } 
  	
      if (child1_pid == 0) {

	close(pipe_fd[0]);
	dup2(pipe_fd[1], STDOUT_FILENO);
	close(pipe_fd[1]);

	if (t->left != NULL) {

	  if (t->left->conjunction == NONE) {

	    execute_command(t->left);

	  } else {

	    execute_conjunction(t->left);

	  }

	}
	    		
	exit(EXIT_SUCCESS);

      }
 
      if ((child2_pid = fork()) < 0)  {

	perror("fork");

      } 

      if (child2_pid == 0) {

	close(pipe_fd[1]);
	dup2(pipe_fd[0], STDIN_FILENO);
	close(pipe_fd[0]);	
	
	if (t->right != NULL) {

	  if (t->right->conjunction == NONE) {

	    execute_command(t->right);

	  } else {

	    execute_conjunction(t->right);

	  }

	}
	    
	exit(EXIT_SUCCESS);

      }

      close(pipe_fd[0]);
      close(pipe_fd[1]);	
      waitpid(child1_pid, NULL, 0);
      waitpid(child2_pid, NULL, 0);

    }
    } else if (t->conjunction == AND) {

	pid_t child1_pid;

	if ((child1_pid = fork()) < 0) {

		perror("fork");

	} 
	if (child1_pid == 0) {

		if (t->left != NULL) {

			  if (t->left->conjunction == NONE) {

			    execute_command(t->left);

			  } else {

			    execute_conjunction(t->left);

			  }		

		}/*
			exit(EXIT_SUCCESS);
		}*/
	if ((WIFEXITED(status)) && (WEXITSTATUS(status) == 0)) {
	/*	printf("if exited: %d\nexit status %d\n", WIFEXITED(status), WEXITSTATUS(status));*/
		if (t->right != NULL) {

	  if (t->right->conjunction == NONE) {

	    execute_command(t->right);

	  } else {

	    execute_conjunction(t->right);

	  }

	}

/*		waitpid(child2_pid, NULL, 0);   
		exit(EXIT_SUCCESS);*/

	} /*else {


		exit(EXIT_SUCCESS);
	
	}	*/	

	exit(EXIT_SUCCESS);

	} else {

	/* parent */
	waitpid(child1_pid, NULL, 0);
	
	}

    } else if (t->conjunction == SUBSHELL) {

		pid_t child1_pid;
		
		if ((child1_pid = fork()) < 0) {

			perror("fork");

		} 

		if (child1_pid == 0) {

			execute(t->left);
			exit(EXIT_SUCCESS);

		} else {
		waitpid(child1_pid, NULL, 0);
		}
	}
  }
}

int execute(struct tree *t) {

  if (t->conjunction == NONE) {

    execute_command(t);

  } else {

    execute_conjunction(t);

  }
  return 0;

}
/*
static void print_tree(struct tree *t) {
  if (t != NULL) {
    print_tree(t->left);

    if (t->conjunction == NONE) {
      printf("NONE: %s, ", t->argv[0]);
    } else {
      printf("%s, ", conj[t->conjunction]);
    }
    printf("IR: %s, ", t->input);
    printf("OR: %s\n", t->output);

    print_tree(t->right);
  }
}
*/
